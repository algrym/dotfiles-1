" vim: fdm=marker fmr={{{,}}} fdl=0
" Author Andreas Louv <andreas@louv.dk>
" This is my personal vim configuration.
" Use at own risk, NO WARRANTY, to the extent permitted by law.

" Basic options {{{

" Vundle {{{

set rtp+=~/.vim/bundle/Vundle.vim

call vundle#begin()

Plugin 'VundleVim/Vundle.vim'

" Theme
Plugin 'romainl/Apprentice'

" Basics
Plugin 'tpope/vim-commentary'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-unimpaired'
Plugin 'tpope/vim-surround'
Plugin 'wellle/targets.vim'
Plugin 'justinmk/vim-sneak'

" Better QF
Plugin 'romainl/vim-qf'

" Easy access of undolist
Plugin 'mbbill/undotree'

" Language specific plugins
Plugin 'pangloss/vim-javascript'
Plugin 'andlrc/rpgle.vim'
Plugin 'elzr/vim-json'

call vundle#end()

" }}}

filetype plugin on

set encoding=utf-8
set modeline
set modelines=2
set autoindent
set showmode
set showcmd
set hidden
set visualbell
set ttyfast
set backspace=indent,eol,start
set relativenumber number
set laststatus=2
set history=1000
set undofile
set undoreload=10000
set list
set listchars=tab:¦\ ,eol:¬,extends:❯,precedes:❮
set lazyredraw
set matchtime=0
set showbreak=↪
set splitbelow
set splitright
set shiftround
set title
set linebreak
set colorcolumn=+1
set shell=/bin/sh
set path=**
set nrformats-=octal

" Spelling
"
set dictionary=/usr/share/dict/words
set spellfile=~/.vim/spell.utf-8.add

" Statusline
set statusline=%r%t\ %y\ \#%n%=0x%B\ [%02p%%\ %l:%c/%L]

" Don't try to highlight lines longer than 200 characters.
set synmaxcol=200

" Time out on key codes but not mappings.
set notimeout
set ttimeout
set ttimeoutlen=10

" Make Vim able to edit crontab files again.
set backupskip=/tmp/*,/private/tmp/*"

" Better Completion
set complete=.,w,b,u,t
set completeopt=longest,menuone,preview

" Resize splits when the window is resized
au VimResized * :wincmd =

" Leader
let mapleader = "\<Space>"
let maplocalleader = "\\"

" Cursorline {{{
" Only show cursorline in the current window and in normal mode.

augroup cline
  set cursorline
  au!
  au WinLeave,InsertEnter * set nocursorline
  au WinEnter,InsertLeave * set cursorline
augroup END

" }}}
" Trailing whitespace {{{
" Only shown when not in insert mode

augroup trailing
  au!
  au InsertEnter * :set listchars-=trail:⌴
  au InsertLeave * :set listchars+=trail:⌴
  set listchars+=trail:⌴
augroup END

" }}}
" Wildmenu completion {{{

set wildmenu
set wildmode=longest,full

set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll            " compiled object files
set wildignore+=migrations                       " Django migrations
set wildignore+=*.pyc                            " Python byte code
set wildignore+=*.orig                           " Merge resolution files

" Clojure/Leiningen
set wildignore+=classes
set wildignore+=lib

" }}}
" Make sure Vim returns to the same line when you reopen a file. {{{
augroup line_return
  au!
  au BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \     execute 'normal! g`"zvzz' |
    \ endif
augroup END

" }}}
" Tabs, spaces, wrapping {{{

set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set nowrap
set textwidth=80
set formatoptions=tcr1

" }}}
" Backups {{{

set noswapfile                    " Got 16GB of memory
set nowritebackup                 " We still have undo list after close/reopen,
                                  " and this is mangling the original creation
                                  " date of the target file.

set undodir=~/.vim/tmp/undo//     " undo files

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif

" }}}
" Color scheme {{{

set t_Co=256
syntax on
set background=dark
colorscheme apprentice

" }}}

" }}}
" Gvim cursor {{{

if has("gui_running")
  set guicursor=a:block-cursor
endif

" }}}
" Abbreviations {{{

iabbrev al@ andreas@louv.dk

" }}}
" Convenience mappings {{{

" Clean trailing whitespace
nnoremap <silent> <leader>ww mz:let z=@/<cr>:%s/\s\+$//<cr>:let @/=z<cr>`z

" zg will add <cword> to the custom spell file, sort that file after adding
nnoremap zg zg:silent ! sort ~/.vim/spell.utf-8.add -o
  \ ~/.vim/spell.utf-8.add<cr>:redraw!<cr>

nnoremap <leader>f :find 
nnoremap <leader>g :grep 
nnoremap <leader>m :make<cr>

" List all buffers in command mode:
nnoremap gb :ls<cr>:b<space>

" Edit file in same directory as current file:
nnoremap <leader>ew :e <C-r>=fnameescape(expand("%:p:h") . "/")<CR>


" Sudo to write
cnoremap w!! w !sudo tee % >/dev/null

" Be able to undo <C-u>
inoremap <c-u> <c-g>u<c-u>

" }}}
" Commands {{{

" JSON / JavaScript {{{

" Remove trailing commas
command! -range=% RemoveComma keepp <line1>,<line2>s/,\ze\_s*[]}]//cg

" Insert missing comma
command! -range=% AddComma keepp <line1>,<line2>s/\(\_s\|[[{,;]\)\@<!\ze\_s\_s*\(\w\w*\|".\{-}\(\\\)\@<!"\):/&,/cg

" }}}

" }}}
" Quick editing {{{

nnoremap <leader>ev :split $MYVIMRC<cr>
nnoremap <leader>ez :split ~/.zshrc<cr>
nnoremap <leader>eg :split ~/.gitconfig<cr>
nnoremap <leader>es :split ~/.vim/spell.utf-8.add<cr>
nnoremap <leader>ei :split ~/.config/i3/config<cr>

nnoremap <leader>sv :source $MYVIMRC<cr>

" }}}
" Searching and movement {{{

set grepprg=grep\ -n\ --exclude-dir=.git\ -R

augroup qfix
    autocmd!
    autocmd QuickFixCmdPost grep,make,lmake nested below cwindow
augroup END

set ignorecase
set smartcase
set hlsearch

set virtualedit+=block

noremap <silent> <C-l> :noh<cr>:call clearmatches()<cr>

runtime macros/matchit.vim

noremap j gj
noremap k gk
noremap gj j
noremap gk k

" Speed up scrolling of the viewport slightly
nnoremap <expr> <C-e> (v:count > 0 ? '' : 3) . '<C-e>'
nnoremap <expr> <C-y> (v:count > 0 ? '' : 3) . '<C-y>'

" Emacs like keys for command line {{{

cnoremap <C-b> <left>
cnoremap <C-f> <right>
cnoremap <C-a> <home>
cnoremap <C-e> <end>
cnoremap <C-d> <del>

" }}}
"
" }}}
" Folding {{{

set foldlevelstart=10

set foldmethod=indent

" Automatic set foldmethod to manual when entering insert mode, this is done to
" prevent vim from unfolding automatic folds, when the code changes.

augroup LazyFolds

  au!
  au InsertEnter,WinLeave * :call <SID>LazyFolds(0)
  au InsertLeave,WinEnter * :call <SID>LazyFolds(1)

  function! s:LazyFolds(type)
    if a:type == 0
      let s:lazy_foldmethod=&foldmethod
      setlocal foldmethod=manual
    else
      execute 'setlocal foldmethod=' . s:lazy_foldmethod
    endif
  endfunction

augroup END

" Make zO recursively open whatever fold we're in, even if it's partially open.
nnoremap zO zczO

set fillchars+=fold:\ 

hi Folded term=standout ctermfg=9 ctermbg=235

function! MyFoldText() " {{{
  let s:left = substitute(getline(v:foldstart), '{{' . '{', '', 'g')
  let s:left = substitute(s:left, '\v\t', repeat(' ', &tabstop), 'g')
  let s:count = printf(' ' . &commentstring, printf('%2d lines', v:foldend - v:foldstart + 1))
  let s:width = &textwidth
  if s:width == 0
    let s:width = 80
  endif
  let s:left_max = s:width - len(s:count)
  let s:left = substitute(s:left, '\v(.{' . (s:left_max - 1) . '}).*', '\1…', '')
  let s:left = s:left . repeat(' ', s:left_max - len(s:left))

  return s:left . s:count
endfunction " }}}

set foldtext=MyFoldText()

" }}}
" Auto Commands {{{

" Disable blink on first + last line
augroup GuiVim

  au!
  au GUIEnter * set vb t_vb=

augroup END

" Make files starting with a shebang executable if they are not already. This
" could potential be dangerous.
augroup AutoChmodX

  au!
  au BufWritePost * call AutoCmdChmodX()

  function! AutoCmdChmodX()
    if getline(1) =~ '^#!'
      let filename = shellescape(@%, 1)
      if stridx(getfperm(@%), 'x') == -1
        call system('chmod +x -- '. filename)
      endif
    endif
  endfunction

augroup END

" Set new files ft to __new__ so that a ftplugin can be ran, this is a nice way
" to enable maps for new files only
augroup NewFT

  au!
  au BufNewFile * setlocal ft=__new__

augroup END

" }}}
" Plugin settings {{{

" Commentary {{{

augroup plugin_commentary
  au!
  au FileType sh,perl,ruby,python setlocal commentstring=#\ %s
  au FileType c,javascript,rpgle setlocal commentstring=//\ %s
  au FileType vim setlocal commentstring=\"\ %s
  au FileType lisp,scheme setlocal commentstring=;\ %s
augroup END

" }}}
" DelimitMate {{{

let delimitMate_excluded_ft = "lisp"

" }}}
" UndotreeToggle {{{

nnoremap <F9> :UndotreeToggle<CR>

" }}}

" }}}
