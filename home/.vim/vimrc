" vim: fdm=marker fmr={{{,}}} fdl=0
" Author Andreas Louv <andreas@louv.dk>
" This is my personal vim configuration.
" Use at own risk, NO WARRANTY, to the extent permitted by law.

" Basic options {{{

" Vundle {{{

set rtp+=~/.vim/bundle/Vundle.vim

call vundle#begin()

Plugin 'VundleVim/Vundle.vim'

" Theme
Plugin 'romainl/Apprentice'

" Basics
Plugin 'tpope/vim-commentary'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-unimpaired'
Plugin 'tpope/vim-surround'
Plugin 'wellle/targets.vim'

" Align text with on regular expression
Plugin 'godlygeek/tabular'

" Readline Style keybinds
Plugin 'tpope/vim-rsi'

" Easy access of undolist
Plugin 'mbbill/undotree'

" Language specific plugins
Plugin 'pangloss/vim-javascript'
Plugin 'andlrc/rpgle.vim'
Plugin 'elzr/vim-json'
Plugin 'leafgarland/typescript-vim'

call vundle#end()

" }}}

filetype plugin on

set encoding=utf-8
set modeline modelines=2
set showmode
set showcmd
set hidden
set visualbell
set ttyfast
set backspace=indent,eol,start
set laststatus=2
set history=1000
set undofile
set undoreload=10000
set list
set listchars=tab:¦\ ,eol:¬,extends:❯,precedes:❮
set lazyredraw
set matchtime=0
set showbreak=↪
set shiftround
set title
set colorcolumn=+1
set shell=/bin/sh
set path=**
set nrformats-=octal
set scrolloff=1 sidescrolloff=5

" Indent
set autoindent
runtime indent.vim

" Spelling
"
set dictionary=/usr/share/dict/words
set spellfile=~/.vim/spell.utf-8.add

" Statusline
set statusline=%r%t\ %m%y\ \#%n%=%02v:%l/%L

" Don't try to highlight lines longer than 200 characters.
set synmaxcol=200

" Time out on key codes but not mappings.
set notimeout
set ttimeout
set ttimeoutlen=10

" Better Completion
set complete=.,w,b,u,t
set completeopt=longest,menuone,preview

" Resize splits when the window is resized
au VimResized * :wincmd =

" Leader
let mapleader = "\<Space>"
let maplocalleader = "\\"

" Trailing whitespace {{{
" Only shown when not in insert mode

augroup trailing
  au!
  au InsertEnter * :set listchars-=trail:⌴
  au InsertLeave * :set listchars+=trail:⌴
  set listchars+=trail:⌴
augroup END

" }}}
" Wildmenu completion {{{

set wildmenu
set wildmode=longest,full
set wildignorecase

set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll            " compiled object files
set wildignore+=migrations                       " Django migrations
set wildignore+=*.pyc                            " Python byte code
set wildignore+=*.orig                           " Merge resolution files

" Clojure/Leiningen
set wildignore+=classes
set wildignore+=lib

" }}}
" Wrapping {{{

set nowrap
set textwidth=80
set formatoptions+=j

" }}}
" Backups {{{

set noswapfile                    " Got 16GB of memory
set nowritebackup                 " We still have undo list after close/reopen,
                                  " and this is mangling the original creation
                                  " date of the target file.

set undodir=~/.vim/tmp/undo//     " undo files

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif

" }}}
" Color scheme {{{

set t_Co=256
syntax on
set background=dark
colorscheme apprentice

" }}}

" }}}
" Gvim cursor {{{

if has("gui_running")
  set guicursor=a:block-cursor
  set guioptions=
  set mouse=
endif

" }}}
" Abbreviations {{{

iabbrev <al@ <andreas@louv.dk
iabbrev al@ andreas@louv.dk

" }}}
" Convenience mappings {{{

" Easy search and jump to match
nnoremap <leader>g :g//#<left><left>
nnoremap <leader>v :g//#<left><left>
cnoremap <expr> <CR> getcmdline() =~# '^[vg]/.*/#$' ? '<CR>:' : '<CR>'

" Clean trailing whitespace
nnoremap <silent> <leader>ww mz:keepp %s/\(\\\)\@<!\s\+$//e<cr>`z

" zg will add <cword> to the custom spell file, sort that file after adding
nnoremap zg zg:silent ! sort ~/.vim/spell.utf-8.add -o
  \ ~/.vim/spell.utf-8.add<cr>:redraw!<cr>

" Store relative movement in the jumplist
nnoremap <expr> j (v:count ? "m'" . v:count : '') . 'j'
nnoremap <expr> k (v:count ? "m'" . v:count : '') . 'k'

nnoremap <leader>f :find<space>
nnoremap <leader>G :grep<space>
nnoremap <leader>m :make<cr>
nnoremap <leader>l :lmake<cr>
nnoremap <leader>h :help<space>

" List all buffers in command mode:
nnoremap gb :ls<cr>:b<space>

" Edit file in same directory as current file:
nnoremap <leader>ew :e <C-r>=fnameescape(expand("%:p:h") . "/")<CR>

" Toggle first boolean after cursor
nnoremap <leader>tt V:!perl -pe 's/true/false/ <bar><bar> s/false/true/'<CR>

" Sudo to write
cnoreabbr w!! w !sudo tee % >/dev/null

" Make Y work like C and D
nnoremap Y y$

" }}}
" Commands {{{

" JSON / JavaScript {{{

" Remove trailing commas
command! -range=% RemoveComma keepp <line1>,<line2>s/,\ze\_s*[]}]//cg

" Insert missing comma
command! -range=% AddComma keepp <line1>,<line2>s/\(\_s\|[[{,;]\)\@<!\ze\_s\_s*\(\w\w*\|".\{-}\(\\\)\@<!"\):/&,/cg

" }}}
" Duplicate word {{{

command! -range=% DupWord keepp <line1>,<line2>s/\(\<\w\+\>\)\zs\_s\+\<\1\>//cg

" }}}
" Uppercase first word after period {{{

command! -range=% UCFirst keepp <line1>,<line2>s/\.\_s\+\zs\l/\u&/cg

" }}}

" }}}
" Quick editing {{{

nnoremap <leader>ev :split $MYVIMRC<cr>
nnoremap <leader>et :split ~/.config/termite/config<cr>
nnoremap <leader>ez :split ~/.zshrc<cr>
nnoremap <leader>eg :split ~/.gitconfig<cr>
nnoremap <leader>es :split ~/.vim/spell.utf-8.add<cr>
nnoremap <leader>ei :split ~/.config/i3/config<cr>

nnoremap <leader>sv :source $MYVIMRC<cr>

" }}}
" Searching and movement {{{

set grepprg=grep\ -n\ --exclude='*.tags'\ --exclude=tags\ --exclude-dir=.git\ -R\ '$*'

set ignorecase
set smartcase
set hlsearch

set virtualedit+=block

noremap <silent> <C-l> :noh<cr>:call clearmatches()<cr>

runtime macros/matchit.vim

" }}}
" Folding {{{

set foldlevelstart=10

" Automatic set foldmethod to manual when entering insert mode, this is done to
" prevent vim from unfolding automatic folds, when the code changes.

augroup LazyFolds

  au!
  au InsertEnter,WinLeave * :call <SID>LazyFolds(0)
  au InsertLeave,WinEnter * :call <SID>LazyFolds(1)

  function! s:LazyFolds(type)
    if a:type == 0
      let b:lazy_foldmethod=&foldmethod
      setlocal foldmethod=manual
    elseif exists('b:lazy_foldmethod')
      execute 'setlocal foldmethod=' . b:lazy_foldmethod
    endif
  endfunction

augroup END

" Make zO recursively open whatever fold we're in, even if it's partially open.
nnoremap zO zczO

set fillchars+=fold:\ 

hi Folded term=standout ctermfg=100 ctermbg=235

function! MyFoldText() " {{{
  let s:left = substitute(getline(v:foldstart), '{{' . '{', '', 'g')
  let s:left = substitute(s:left, '\v\t', repeat(' ', &tabstop), 'g')
  let s:count = printf(' ' . &commentstring, printf('%2d lines', v:foldend - v:foldstart + 1))
  let s:width = &textwidth
  if s:width == 0
    let s:width = 80
  endif
  let s:left_max = s:width - len(s:count)
  let s:left = substitute(s:left, '\v(.{' . (s:left_max - 1) . '}).*', '\1…', '')
  let s:left = s:left . repeat(' ', s:left_max - len(s:left))

  return s:left . s:count
endfunction " }}}

set foldtext=MyFoldText()

" }}}
" FileType Detect {{{

augroup FT_Detect

  au!
  au BufNewFile,BufRead *.cvim setlocal filetype=markdown.cvim
  au BufNewFile,BufRead *.widget setlocal filetype=javascript.widget
  au BufNewFile,BufRead *.cvim setlocal filetype=markdown.cvim
  au BufNewFile,BufRead *.widget setlocal filetype=javascript.widget
  au BufNewFile,BufRead *.xjson,*.xpd,*.ns,*.dmd,*.lib setlocal filetype=json
  au BufNewFile,BufRead *.cvim setlocal filetype=markdown.cvim
  au BufNewFile,BufRead *.widget setlocal filetype=javascript.widget
  au BufNewFile,BufRead *.xjson,*.xpd,*.ns,*.dmd,*.lib setlocal filetype=json
  au BufNewFile,BufRead *.md,*.m*down setlocal filetype=markdown
  au BufNewFile,BufRead *.tpl setlocal filetype=html.mustache syntax=html.mustache
  au BufNewFile,BufRead *.aspx,*.asmx setlocal filetype=rpgle
  au BufNewFile,BufRead .xinitrc setlocal filetype=sh syntax=sh

augroup END

" }}}
" Auto Commands {{{

" Disable blink on first + last line
augroup GuiVim

  au!
  au GUIEnter * set vb t_vb=

augroup END

" Make files starting with a shebang executable if they are not already. This
" could potential be dangerous.
augroup AutoChmodX

  au!
  au BufWritePost * call AutoCmdChmodX()

  function! AutoCmdChmodX()
    if getline(1) =~ '^#!'
      let filename = shellescape(@%, 1)
      if stridx(getfperm(@%), 'x') == -1
        call system('chmod +x -- '. filename)
      endif
    endif
  endfunction

augroup END

" }}}
" Plugin settings {{{

" Commentary {{{

augroup plugin_commentary
  au!
  au FileType sh,perl,ruby,python setlocal commentstring=#\ %s
  au FileType c,javascript,rpgle setlocal commentstring=//\ %s
  au FileType vim setlocal commentstring=\"\ %s
  au FileType lisp,scheme setlocal commentstring=;\ %s
augroup END

" }}}
" UndotreeToggle {{{

let g:undotree_SetFocusWhenToggle = 1
nnoremap <F9> :UndotreeToggle<CR>

function! g:Undotree_CustomMap()
  map <buffer> <c-n> J
  map <buffer> <c-p> K
endfunction


" }}}

" }}}
